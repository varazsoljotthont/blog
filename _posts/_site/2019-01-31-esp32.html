<p><strong>Espressif <a href="https://www.espressif.com/en/news/ESP32_Modules_Now_Support_LittlevGL_and_%CE%BCGFX">has announced</a> that they support LittlevGL on their ESP32 modules. 
Adding GUI to your ESP32 based IoT device is easier than ever.  I made it work in 15 minutes, so it’s really worth a try!</strong></p>

<p>These are some examples created by the Espressif:</p>

<p><img src="/assets/esp32/esp_example1.jpg" alt="Audio player example on ESP32 with LittlevGL" />
<em>Audio player example on ESP32 with LittlevGL</em></p>

<p><br /></p>

<p><img src="/assets/esp32/esp_example2.jpg" alt="Coffee maker and thermostat example on ESP32 with LittlevGL" />
<em>Coffee maker and thermostat example on ESP32 with LittlevGL</em></p>

<h2 id="still-dont-know-esp32">Still don’t know ESP32?</h2>

<p><a href="https://www.espressif.com/en/products/hardware/esp32/overview">ESP32</a> is powerful SoC (System on Chip) develped by <a href="https://www.espressif.com/en">Espressif</a>. 
The modules built with the chip are extremely popular in IoT applications where <strong>connectivity</strong> and <strong>low-power operation</strong> are a must. In addition, ESP32 provides high performance with a <strong>dual-core 200 MHz MCU</strong>. 
The modules are usually equipped with <strong>external flash (typically 4 MB)</strong> which can be mapped as program memory.</p>

<p>Regarding the connectivity, the modules come with <strong>fully certified Wi-Fi, BT, and BLE</strong> interfaces.</p>

<p>One of the most <strong>popular modules</strong> is <a href="https://hu.mouser.com/ProductDetail/Espressif-Systems/ESP32-WROOM-32?qs=chTDxNqvsyltcwz%2FUUJDtQ%3D%3D">ESP32 WROOM</a> for <strong>only $4</strong>.</p>

<p>To get started you should buy a <strong>development board</strong> with an ESP32 module. For example <a href="https://hu.mouser.com/ProductDetail/Espressif-Systems/ESP32-DevKitC?qs=sGAEpiMZZMurtJ7VwBTl0Rm64lZhrtuCiot%2fLDk%252bF2ilRoHMowv5Wg%3d%3d">ESP32-DevkitC</a></p>

<p><img src="/assets/esp32/esp_devkitc.jpg" alt="ESP32-DevKitC" />.</p>

<p>You <strong>don’t need any extra hardware</strong> like a programmer because the ESP32 can be <strong>programmed via a Serial Port</strong> using a simple Micro USB cable.</p>

<h2 id="gui-with-esp32">GUI with ESP32</h2>

<p>Although the ESP32 chip doesn’t have an RGB LCD interface or a parallel port to drive a display it has <strong>fast SPI ports</strong>.</p>

<p><a href="https://cdn-shop.adafruit.com/datasheets/ILI9341.pdf">ILI9341</a>, 
<a href="https://www.numworks.com/shared/binary/datasheets/st7789v-lcd-controller-73f8bc3e.pdf">ST7789</a> 
<a href="https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf">SSD1306</a> are three display controllers which actually have SPI interface and you will find a lot of displays modules equipped with them.</p>

<h3 id="what-graphical-performance-can-you-expect-from-esp32">What graphical performance can you expect from ESP32?</h3>

<p>There are two main things which determine the graphical performance:</p>
<ol>
  <li><strong>Rendering time</strong> the time to draw a frame (or a part of it).</li>
  <li><strong>Flushing time</strong> the time to transfer the rendered image to the display.</li>
</ol>

<p>The <strong>rendering time</strong> depends on the speed of the MCU. A GPU can speed it up but unfortunately, ESP32 doesn’t have any. Anyway, a 200 MHz core speed should be fine the render nice GUIs fast enough!</p>

<p>The <strong>flushing time</strong> depends on the system’s architecture and the peripheries of the MCU. In the case of ESP32, you need to use SPI to send the rendered frame to the display controller.</p>

<h3 id="some-calculations">Some calculations</h3>
<p>By default the <strong>maximum SPI clock speed</strong> of ESP32 is <strong>40 MHz</strong>. What does it mean? On a 320x240 disply with 16 bit color depth you need to transfer  <em>320 x 240 x 16 = 1,228,000 bits</em>. On 40 MHz it means <em>1,228,000 / 40,000,000 = 30 ms</em>.</p>

<p>So to <strong>transfer a full frame 30 ms</strong> is required.</p>

<p>If you have e.g. 40 ms rendering time the whole process takes 70 ms which means only 14 FPS.</p>

<h3 id="how-to-speed-esp32-for-gui-applications">How to speed ESP32 for GUI applications?</h3>

<p>There are two options:</p>
<ol>
  <li><strong>Speed up SPI</strong></li>
  <li><strong>Make the flushing and rendering parallel</strong></li>
</ol>

<p>Let’s discuss the <strong>SPI speed</strong> first. This table is from ILI9341’s datasheet (page 230):</p>

<p><img src="/assets/esp32/ili9341_spi_timing.png" alt="ILI9341 SPI timing" />
<em>ILI9341 SPI timing</em></p>

<p>The first line says the one clock period can be minimum 100 ns which means only 10 MHz. It would be extremely slow.</p>

<p>It turned out that ILI9341 actually <a href="http://www.eevblog.com/forum/microcontrollers/ili9341-lcd-driver-max-spi-clock-speed/">works at higher clock rates</a> too. 
They say 48MHz is even possible but it’s still not a big gain compared to the 40 MHz in the previous calculation.</p>

<p>Anyway, in ESP32 you can <strong>increase the SPI speed to 80 MHz</strong> if you use dedicated pins.</p>

<p>According to the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/spi_master.html#gpio-matrix-and-iomux">ESP32 SPI documentation</a>:</p>
<blockquote>
  <p>When the GPIO matrix is used, signals faster than 40MHz cannot propagate and the setup time of MISO is more easily violated, since the input delay of MISO signal is increased. The maximum clock frequency with GPIO Matrix is 40MHz or less, whereas using all IOMUX pins allows 80MHz.</p>
</blockquote>

<p>So just choose the following SPI pins to have an 80 MHz clock speed:</p>

<p><img src="/assets/esp32/esp_spi_80mhz.png" alt="ESP32 SPI: 80 MHz pin configuration" />
<em>ESP32 SPI: 80 MHz pin configuration</em></p>

<p>To drive a display only <em>MOSI</em> and <em>SCLK</em> is required from the table.</p>

<p>So let’s use the faster pins. The maximum clock rate is still 40 MHz because of ILI9341 but hopefully, it will give better signals.</p>

<p>To <strong>make the rendering and flushing parallel</strong> you should use <strong>SPI with DMA</strong>. The DMA makes possible to send the rendered image via SPI in the background and let the CPU to do other things. 
ESP32 supports using DMA with SPI so it’s just the question of the driver and some LittlevGL configuration. (Enable <code class="highlighter-rouge">LV_VDB_DOUBLE</code> in <code class="highlighter-rouge">lv_conf.h</code>)</p>

<h2 id="build-and-flush-and-official-example">Build and flush and official example</h2>

<h3 id="install-esp32-toolchain">Install ESP32 toolchain</h3>
<p>To get started you need to <strong>install ESP32 development toolchain</strong>.  Refer to this <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/index.html">Guide</a> and follow the steps.</p>

<h3 id="get-esp-iot-solution">Get ESP IoT Solution</h3>
<p><a href="https://github.com/espressif/esp-iot-solution">ESP IoT Solution</a> is a huge collection of</p>
<ul>
  <li>drivers</li>
  <li>libraries</li>
  <li>and examples</li>
</ul>

<p>Clone it somewhere (preferably in the <code class="highlighter-rouge">esp</code> folder where the toolchain was installed):</p>
<ol>
  <li><code class="highlighter-rouge">cd ~/esp/</code></li>
  <li><code class="highlighter-rouge">git clone https://github.com/espressif/esp-iot-solution --recurse-submodules</code></li>
  <li><code class="highlighter-rouge">export IOT_SOLUTION_PATH=~/esp/esp-iot-solution</code></li>
</ol>

<h3 id="configure-an-example">Configure an example</h3>
<p>Choose an example and configure it:</p>
<ol>
  <li><code class="highlighter-rouge">cd esp-iot-solution/examples/hmi/lvgl_example</code></li>
  <li><code class="highlighter-rouge">make defconfig</code></li>
  <li><code class="highlighter-rouge">make menuconfig</code></li>
</ol>

<p>In the <strong>menuconfig</strong> go to <strong>IoT Solution Settings &gt; IoT Component Management &gt; HMI Components &gt; LVGL Settings</strong></p>

<p>In <strong>Config Driver</strong></p>
<ul>
  <li>Choose your screen driver. In my case it was ILI9341</li>
  <li>Set the Screen pins as shown in the image below</li>
  <li>Set the LCD SPI clock to 40,000,000. It was the maximum value so the previously calculated 80 MHz can’t be tried here.</li>
</ul>

<p><img src="/assets/esp32/menuconfig1.jpg" alt="Configuration of ESP to run a LittlevGL example" />
<em>Configuration of ESP to run a LittlevGL example</em></p>

<p>If you enter into Touch Screen pin configuration you will see only <em>CS</em> and <em>IRQ</em> pin settings. 
Which means that it uses the same SPI as the Screen driver and the <em>MOSI</em>, <em>MISO</em> and <em>CLK</em> pins are shared.
However, my screen has dedicated SPI pins for the touchpad and the screen and I didn’t have “Y” cables. So I disabled touchpad for now in “LittlevGL Touchscreen Enable”.</p>

<p>In the main menu of <em>menuconfig</em> in  <em>Serial flasher config</em> be sure the correct Serial port is selected. (ESP32 needs to be connected to your PC to see which Serial port is used.)</p>

<p>After that save the settings and exit menuconfig.</p>

<h3 id="build-and-flash">Build and flash</h3>
<p>To build and flash type into the Terminal:</p>
<ol>
  <li><code class="highlighter-rouge">make</code> to build the project. Or <code class="highlighter-rouge">make -j8</code> to build on 8 threads.</li>
  <li><code class="highlighter-rouge">make flash</code> to program the ESP</li>
</ol>

<p>And the result is:
<img src="/assets/esp32/esp_official_littlevgl_example.jpg" alt="Running an official LittlevGL example on ESP32" />
 <em>Running an official LittlevGL example on ESP32</em></p>

<h2 id="littlevgl-with-esp-idf-directly">LittlevGL with ESP-IDF directly</h2>
<p>If you want a <strong>more simple project</strong> with more freedom you should use <a href="https://github.com/espressif/esp-idf">ESP-IDF</a> which is the core ESP SDK.</p>

<p>There is a LittlevGL project you can use with ESP-IDF: <a href="https://github.com/littlevgl/esp32_ili9431">https://github.com/littlevgl/esp32_ili9431</a></p>

<p>This project comes with an <strong>ILI9341</strong> display driver and an <strong>XPT2046</strong> touchpad driver. You can customize these drivers according to your needs.</p>

<ol>
  <li>Get this projects: <code class="highlighter-rouge">git clone https://github.com/littlevgl/esp32_ili9431.git --recurse-submodules</code></li>
  <li>Add LittlevGL to the build. Copy <code class="highlighter-rouge">lvgl_component.mk</code> and <code class="highlighter-rouge">lv_example_component.mk</code> as <code class="highlighter-rouge">component.mk</code> to the <code class="highlighter-rouge">lvgl</code> and <code class="highlighter-rouge">lv_examples</code> directories respectively.</li>
  <li>Connect the touch pad (optional):
    <ul>
      <li>MOSI : 32</li>
      <li>MISO : 25</li>
      <li>SCLK : 26</li>
      <li>CS : 33</li>
      <li>IRQ : 25</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">make</code></li>
  <li><code class="highlighter-rouge">make flash</code></li>
</ol>

<p><img src="/assets/esp32/esp32_littelvgl_gui.jpg" alt="Configuration of ESP to run a LittlevGL example" />
<em>Configuration of ESP to run a LittlevGL example</em></p>

<h2 id="summary">Summary</h2>

<p>ESP-IoT-Solution is a great an easy to use framework. As you can see it takes only a few minutes to get started.</p>

<p>However, you can use ESP-IDF as well to try LittlevGL. This way you will have more control over your project.</p>

<p>If you have a product with ESP32 and LittelvGL you can share it among <a href="https://blog.littlevgl.com/2018-12-26/references">LittlevGL References</a>.</p>

